<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Combinatorial Intuition for the Binomial Theorem | False Productivity</title>
<meta name="keywords" content="combinatorics, binomial theorem" />
<meta name="description" content="Rough proof of the formula for the binomial coefficient using simple counting">
<meta name="author" content="colossal_pepe">
<link rel="canonical" href="https://colossal-pepe.github.io/false-productivity/posts/2021-5/combinatorial-intuition-for-binomial-theorem/" />
<link crossorigin="anonymous" href="/false-productivity/assets/css/stylesheet.min.b50dea21cb69b925c783abc4870e38fef3e55317f404eef2740034ed7a1c0ac5.css" integrity="sha256-tQ3qIctpuSXHg6vEhw44/vPlUxf0BO7ydAA07XocCsU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://colossal-pepe.github.io/false-productivity/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://colossal-pepe.github.io/false-productivity/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://colossal-pepe.github.io/false-productivity/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://colossal-pepe.github.io/false-productivity/apple-touch-icon.png">
<link rel="mask-icon" href="https://colossal-pepe.github.io/false-productivity/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.83.1" />

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js" integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>
<meta property="og:title" content="Combinatorial Intuition for the Binomial Theorem" />
<meta property="og:description" content="Rough proof of the formula for the binomial coefficient using simple counting" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://colossal-pepe.github.io/false-productivity/posts/2021-5/combinatorial-intuition-for-binomial-theorem/" /><meta property="og:image" content="https://colossal-pepe.github.io/false-productivity/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-30T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-05-30T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://colossal-pepe.github.io/false-productivity/papermod-cover.png"/>

<meta name="twitter:title" content="Combinatorial Intuition for the Binomial Theorem"/>
<meta name="twitter:description" content="Rough proof of the formula for the binomial coefficient using simple counting"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://colossal-pepe.github.io/false-productivity/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Combinatorial Intuition for the Binomial Theorem",
      "item": "https://colossal-pepe.github.io/false-productivity/posts/2021-5/combinatorial-intuition-for-binomial-theorem/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Combinatorial Intuition for the Binomial Theorem",
  "name": "Combinatorial Intuition for the Binomial Theorem",
  "description": "Rough proof of the formula for the binomial coefficient using simple counting",
  "keywords": [
    "combinatorics", "binomial theorem"
  ],
  "articleBody": "The unrelated counting problem First, let’s talk about a seemingly unrelated counting puzzle. In an $n \\times m$ grid, let each cell be denoted as $(\\text{row number, column number})$. The top-left cell will be $(1,1)$ and bottom-right cell will be $(n,m)$. If the only allowed direction is right and down, count the number of ways to go from $(1,1)$ to $(n,m)$.\nSolution With Counting Let $f(x,y)$ be the number of ways to go to cell $(x,y)$. Notice that for any cell, you reach it from either the cell above it, or from the cell to the left of it. This diagram should illustrate it nicely:\nSo we get the following recurrence relation: $$ f(x,y) = \\begin{cases} f(x-1,y)+f(x,y-1) \u0026 \\text{if $x,y  1$} \\\\[0.5em] 1 \u0026 \\text{otherwise} \\end{cases} $$\nSolution with combinatorics Let D and R be the action of going down and right respectively. In a sequence of DDD…RRR… which takes us to cell $(n,m)$, the number of D’s will be $n-1$ and the number of R’s will be $m-1$. So the above problem is simplified to the following problem: how many different arrangements does the sequence DDD…RRR… have? If you have ever studied combinatorics, the answer will be immediately obvious: $$ f(x,y) = {x+y-2 \\choose x-1} $$ If you don’t understand how this works, go here for the Wikipedia page and here to get a brief understanding.\nRelating to Pascal’s Triangle Here is a picture of Pascal’s triangle to help us understand:\nNote: I’ll use 1-based indexing meaning row numbers and column numbers will start from 1.\nLet’s try to calculate the 2nd number on the 5th row, which is 4. Some of the numbers have been marked out because we don’t need those when trying to calculate the 4 we want, we are only concerned with the numbers that we need. This also follows what we want from the Binomial theorem, we don’t always want to find all the coefficients, we always calculate a single coefficient.\nNow, notice that after removing the unnecessary cells, the remaining cells will form a rectangle (from the 1st cell to our desired cell). You might already see where I’m going with this. But proving that is out of the scope for this article (also, I can’t prove it). Let the desired number be on row $x$ and column $y$ of the triangle. Then our rectangle will have $x-y+1$ rows and $y$ columns.\nBut notice how we count each cell in pascal’s triangle. It’s not that difficult to see that this pattern of counting is identical to our SUCP (Seemingly Unrelated Counting Problem). I recommend deriving the binomial theorem from here on yourself. But you can read further if you want.\nDeriving the Binomial Theorem Let $g(x,y)$ be the number on row $x$ and column $y$ of the triangle. So the recurrence relation is: $$ g(x,y) = \\begin{cases} g(x-1,y-1)+g(x-1,y) \u0026 \\text{if $x,y  1$} \\\\[0.5em] 1 \u0026 \\text{otherwise} \\end{cases} $$ This is also a formula for the binomial theorem but nobody uses this. Naturally, we are more concerned about the closed-form formula. We already know that $x$ is the exponent we are raising our binomial to and we are calculating the $y^\\text{th}$ of the expansion. Since we already have the dimensions of the rectangle, we can simply input them in here and get this: $$ g(x,y) = {x-y+1-1+y-1 \\choose y-1} = {x-1 \\choose y-1} $$\nSome interesting relations to CS A naive implementation of the recursive algorithm is this:\nfunction countPathsInGrid(x, y): if x is 1 or y is 1: return 1 else: return countPathsInGrid(x-1, y) + countPathsInGrid(x, y-1) This results in exponential time complexity. This implementation uses $O(1)$ memory. This algorithm’s speed can be improved using dynamic programming:\nlet ways[i][j] store the number of ways to go from (1,1) to (i,j) function countPathsInGrid(x, y): if ways[i][j] is known: return ways[i][j] else if x is 1 or y is 1: return 1 else: ways[i][j] = countPathsInGrid(x-1, y) + countPathsInGrid(x, y-1) return ways[i][j] Now, the time complexity has been reduced to only $O(nm)$ but the memory complexity has increased to $O(nm)$. The memory complexity can be reduced further by counting ways row by row, so the ways array will only store values from the above row. But the speed of this algorithm can be further improved without sacrificing memory:\nfunction countPathsInGrid(x, y): ans = 1 for i such that x The above algorithm has time complexity $O(\\max (n,m))$.\nSo, that is all I think I want to write in this post. I don’t like changing editing post after it’s published.\n",
  "wordCount" : "785",
  "inLanguage": "en",
  "datePublished": "2021-05-30T00:00:00Z",
  "dateModified": "2021-05-30T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "colossal_pepe"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://colossal-pepe.github.io/false-productivity/posts/2021-5/combinatorial-intuition-for-binomial-theorem/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "False Productivity",
    "logo": {
      "@type": "ImageObject",
      "url": "https://colossal-pepe.github.io/false-productivity/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://colossal-pepe.github.io/false-productivity/" accesskey="h" title="False Productivity (Alt + H)">False Productivity</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://colossal-pepe.github.io/false-productivity/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://colossal-pepe.github.io/false-productivity/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://colossal-pepe.github.io/false-productivity/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://colossal-pepe.github.io/false-productivity/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Combinatorial Intuition for the Binomial Theorem
    </h1>
    <div class="post-description">
      Rough proof of the formula for the binomial coefficient using simple counting
    </div>
    <div class="post-meta">May 30, 2021&nbsp;·&nbsp;colossal_pepe
</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <div class="details">Table of Contents</div>
        </summary>
        <div class="inner"><ul>
                <li>
                    <a href="#the-unrelated-counting-problem" aria-label="The unrelated counting problem">The unrelated counting problem</a></li>
                <li>
                    <a href="#solution-with-counting" aria-label="Solution With Counting">Solution With Counting</a></li>
                <li>
                    <a href="#solution-with-combinatorics" aria-label="Solution with combinatorics">Solution with combinatorics</a></li>
                <li>
                    <a href="#relating-to-pascals-triangle" aria-label="Relating to Pascal&amp;rsquo;s Triangle">Relating to Pascal&rsquo;s Triangle</a></li>
                <li>
                    <a href="#deriving-the-binomial-theorem" aria-label="Deriving the Binomial Theorem">Deriving the Binomial Theorem</a></li>
                <li>
                    <a href="#some-interesting-relations-to-cs" aria-label="Some interesting relations to CS">Some interesting relations to CS</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="the-unrelated-counting-problem">The unrelated counting problem<a hidden class="anchor" aria-hidden="true" href="#the-unrelated-counting-problem">#</a></h2>
<p>First, let&rsquo;s talk about a seemingly unrelated counting puzzle. In an $n \times m$ grid, let each cell be denoted as $(\text{row number, column number})$. The top-left cell will be $(1,1)$ and bottom-right cell will be $(n,m)$. If the only allowed direction is right and down, count the number of ways to go from $(1,1)$ to $(n,m)$.</p>
<h2 id="solution-with-counting">Solution With Counting<a hidden class="anchor" aria-hidden="true" href="#solution-with-counting">#</a></h2>
<p>Let $f(x,y)$ be the number of ways to go to cell $(x,y)$. Notice that for any cell, you reach it from either the cell above it, or from the cell to the left of it. This diagram should illustrate it nicely:</p>
<p><img loading="lazy" src="https://i.imgur.com/bci2h5r.png" alt="Grid ways"  />
</p>
<p>So we get the following recurrence relation:
$$
f(x,y) = \begin{cases}
f(x-1,y)+f(x,y-1) &amp; \text{if $x,y &gt; 1$} \\[0.5em]
1 &amp; \text{otherwise}
\end{cases}
$$</p>
<h2 id="solution-with-combinatorics">Solution with combinatorics<a hidden class="anchor" aria-hidden="true" href="#solution-with-combinatorics">#</a></h2>
<p>Let <em>D</em> and <em>R</em> be the action of going down and right respectively. In a sequence of <em>DDD&hellip;RRR&hellip;</em> which takes us to cell $(n,m)$, the number of <em>D</em>&rsquo;s will be $n-1$ and the number of <em>R</em>&rsquo;s will be $m-1$. So the above problem is simplified to the following problem: how many different arrangements does the sequence <em>DDD&hellip;RRR&hellip;</em> have? If you have ever studied combinatorics, the answer will be immediately obvious:
$$
f(x,y) = {x+y-2 \choose x-1}
$$
If you don&rsquo;t understand how this works, go <a href="https://en.wikipedia.org/wiki/Combination">here</a> for the Wikipedia page and <a href="https://www.mathsisfun.com/combinatorics/combinations-permutations.html">here</a> to get a brief understanding.</p>
<h2 id="relating-to-pascals-triangle">Relating to Pascal&rsquo;s Triangle<a hidden class="anchor" aria-hidden="true" href="#relating-to-pascals-triangle">#</a></h2>
<p>Here is a picture of Pascal&rsquo;s triangle to help us understand:</p>
<p><img loading="lazy" src="https://i.imgur.com/qpwvFdb.png" alt="Pascal&amp;rsquo;s Triangle"  />
</p>
<p>Note: I&rsquo;ll use 1-based indexing meaning row numbers and column numbers will start from 1.</p>
<p>Let&rsquo;s try to calculate the 2nd number on the 5th row, which is 4. Some of the numbers have been marked out because we don&rsquo;t need those when trying to calculate the 4 we want, we are only concerned with the numbers that we need. This also follows what we want from the Binomial theorem, we don&rsquo;t always want to find all the coefficients, we always calculate a single coefficient.</p>
<p>Now, notice that after removing the unnecessary cells, the remaining cells will form a rectangle (from the 1st cell to our desired cell). You might already see where I&rsquo;m going with this. But proving that is out of the scope for this article (also, I can&rsquo;t prove it). Let the desired number be on row $x$ and column $y$ of the triangle. Then our rectangle will have $x-y+1$ rows and $y$ columns.</p>
<p>But notice how we count each cell in pascal&rsquo;s triangle. It&rsquo;s not that difficult to see that this pattern of counting is identical to our SUCP (Seemingly Unrelated Counting Problem). I recommend deriving the binomial theorem from here on yourself. But you can read further if you want.</p>
<h2 id="deriving-the-binomial-theorem">Deriving the Binomial Theorem<a hidden class="anchor" aria-hidden="true" href="#deriving-the-binomial-theorem">#</a></h2>
<p>Let $g(x,y)$ be the number on row $x$ and column $y$ of the triangle. So the recurrence relation is:
$$
g(x,y) = \begin{cases}
g(x-1,y-1)+g(x-1,y) &amp; \text{if $x,y &gt; 1$} \\[0.5em]
1 &amp; \text{otherwise}
\end{cases}
$$
This is also a formula for the binomial theorem but nobody uses this. Naturally, we are more concerned about the closed-form formula. We already know that $x$ is the exponent we are raising our binomial to and we are calculating the $y^\text{th}$ of the expansion. Since we already have the dimensions of the rectangle, we can simply input them in here and get this:
$$
g(x,y) = {x-y+1-1+y-1 \choose y-1} = {x-1 \choose y-1}
$$</p>
<h2 id="some-interesting-relations-to-cs">Some interesting relations to CS<a hidden class="anchor" aria-hidden="true" href="#some-interesting-relations-to-cs">#</a></h2>
<p>A naive implementation of the recursive algorithm is this:</p>
<pre><code>function countPathsInGrid(x, y):
    if x is 1 or y is 1:
        return 1
    else:
        return countPathsInGrid(x-1, y) + countPathsInGrid(x, y-1)
</code></pre><p>This results in exponential time complexity. This implementation uses $O(1)$ memory. This algorithm&rsquo;s speed can be improved using dynamic programming:</p>
<pre><code>let ways[i][j] store the number of ways to go from (1,1) to (i,j)
function countPathsInGrid(x, y):
    if ways[i][j] is known:
        return ways[i][j]
    else if x is 1 or y is 1:
        return 1
    else:
        ways[i][j] = countPathsInGrid(x-1, y) + countPathsInGrid(x, y-1)
        return ways[i][j]
</code></pre><p>Now, the time complexity has been reduced to only $O(nm)$ but the memory complexity has increased to $O(nm)$. The memory complexity can be reduced further by counting ways row by row, so the <code>ways</code> array will only store values from the above row. But the speed of this algorithm can be further improved without sacrificing memory:</p>
<pre><code>function countPathsInGrid(x, y):
    ans = 1
    for i such that x &lt;= i &lt;= x + y - 2:
        ans = ans * i
    for i such that 1 &lt;= i &lt;= x:
        ans = ans / i
    return ans
</code></pre><p>The above algorithm has time complexity $O(\max (n,m))$.</p>
<p>So, that is all I think I want to write in this post. I don&rsquo;t like changing editing post after it&rsquo;s published.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://colossal-pepe.github.io/false-productivity/tags/combinatorics/">combinatorics</a></li>
      <li><a href="https://colossal-pepe.github.io/false-productivity/tags/binomial-theorem/">binomial theorem</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://colossal-pepe.github.io/false-productivity/posts/2021-5/quadratic-equation-roots/">
    <span class="title">Next Page »</span>
    <br>
    <span>Sum and Product of Roots in Quadratic Equations</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://colossal-pepe.github.io/false-productivity/">False Productivity</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
