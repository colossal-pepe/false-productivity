[{"content":"Abridged Problem Statement The original statement is short enough, go here for it.\nSolution Without loss of generality, let $a \\leq b$ (if not we can just swap the two). Let $S_m$ denote how much we can add to $a$ and/or $b$ with $m$ operations. Of course, $S_m = 1+2+\\ldots + m$. It\u0026rsquo;s obvious that for some $k$, if $S_k = b - a$ then $k$ will be the answer. But if there is no such $k$, then we will have to make $m$ operations such that $S_m \u0026gt; b - a$. Let\u0026rsquo;s take $a = 1$ and $b = 3$ as an example. The equality after our operations can be expressed like this: $$ a+1+3 = b+2 $$ But it can also be expressed like this: $$ \\begin{align*} \u0026amp; a+1-2+3-2 = b+2 \\\\[0.7em] \\implies \u0026amp; a+S_3-2 = b+2 \\end{align*} $$ If we write it more generally, we can write: $$ \\begin{align*} \u0026amp; a+S_m - p = b + p \\\\[0.7em] \\implies \u0026amp; a + S_m - b = 2p \\end{align*} $$ So $S_m$ simply needs to satisfy 2 conditions:\n $S_m \\geq b - a$ $a + S_m - b$ is even  So we should simply start from $m = 0$ and increment $m$ by $1$ until $S_m$ satisfies the above 2 conditions.\nCode Time complexity: Since $S_m = \\sum_{i = 0}^{m} i = \\frac{m(m+1)}{2}$, we also have: $$ \\frac{m(m+1)}{2} \\approx |a - b| \\\\[0.7em] \\implies m \\approx \\sqrt{2|a-b|} $$ There\u0026rsquo;s no point in caring about the precise value of $m$ for the time complexity. So the time complexity will be $\\mathcal{O}{\\left( \\sqrt{|a-b|} \\right)}$.\n#include \u0026lt;iostream\u0026gt;using namespace std; typedef long long ll; ll t, a, b; int main() { cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; ll i = 0, sum = 0; while (sum \u0026lt; abs(a - b) or (a + sum - b)%2) { i += 1; sum += i; } cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-6/a-and-b/","summary":"Abridged Problem Statement The original statement is short enough, go here for it.\nSolution Without loss of generality, let $a \\leq b$ (if not we can just swap the two). Let $S_m$ denote how much we can add to $a$ and/or $b$ with $m$ operations. Of course, $S_m = 1+2+\\ldots + m$. It\u0026rsquo;s obvious that for some $k$, if $S_k = b - a$ then $k$ will be the answer. But if there is no such $k$, then we will have to make $m$ operations such that $S_m \u0026gt; b - a$.","title":"A and B"},{"content":"Abridged Problem Statement Given an array $a$ of $n$ integers, output \u0026ldquo;YES\u0026rdquo; if for any integer 2 integers $i$ and $j$ ($-\\infty \\leq i \u0026lt; j \\leq \\infty)$, $i+a_{i \\bmod n} = j+a_{j \\bmod n}$, otherwise output \u0026ldquo;NO\u0026rdquo;. Go here for the full statement.\nSolution Note: If you don\u0026rsquo;t know shit about modular arithmetic, go here and learn about it. Also, we will be staying strictly in the realm of integers. And of course, $a$ will be 0-indexed because $i \\bmod n$ can be $0$. Finally, instead of saying guest from room $x$ goes to room $y$, I\u0026rsquo;ll just say guest $x$ goes to room $y$.\nLet $f(k) = k + a_{k \\bmod n}$ which is just the function that gives the new room for the guest who was at room $k$ before the shuffling. Also, let\u0026rsquo;s name the 1st term the identity term and the 2nd term will be named the offset term.\nFirst, let\u0026rsquo;s try to obtain a pattern. With a bit of trying out examples and drawing hotels, we can see some pattern: if $n = 4$, we can see that $f(2) + 4 = f(6)$ and also $f(2) + 2 \\cdot 4 = f(10)$. It\u0026rsquo;s easy to see why this would happen, since $2 \\equiv 6 \\equiv 10 \\pmod 8$, their offset will be the same (in this case, it will be $a_2$). So the difference between their shuffled rooms will simply be the difference in their identity. Mathematically speaking, if $x$ is between $0$ and $n - 1$ (it doesn\u0026rsquo;t need to be but for the sake of simplicity and modulo $n$), we have: $$ f(x + mn) = x + a_{x \\bmod n} + mn = f(x) + mn $$ Remember that $x \\equiv x + mn \\pmod n$, this is to say that the middle part of the above equation makes sense. Notice how this will will look if we draw a hotel. Let\u0026rsquo;s say $f(2) = 3$, then the hotel will look like this:\nNotice that I have divided the hotel into parts containing $4$ or more generally, $n$ rooms. In each part, the 3rd room is being occupied by guests of the form $2 + mn$. Now, if there is a collision, say guest $-1$ goes to room $3$, then all guests of the form $-1 + mn$ will occupy the 3rd room in each part. Again, mathematically speaking, there are collisions if $i \\not\\equiv j \\pmod n$ but $f(i) = f(j)$, then it implies that $f(i + mn) = f(j + mn)$. Since $f(x) \\bmod n$ gives the room number within a part (in the above example, $f(2) \\bmod 4 = 3$ and so that guy\u0026rsquo;s located in room $3$), we can just check if all rooms within any part contain more than 1 guest. The algorithm is pretty simple:\n Calculate $f(x) \\bmod n$ for all $0 \\leq x \\leq n - 1$ and insert it into a set or mark 1 in a boolean array or count occurrences in a map or any data structure that allows remembering things quickly. If $f(x) \\bmod n$ already occupied by some other number, we know that all rooms in every part will be occupied by that number so there will be infinite collisions actually! Hence we can print \u0026ldquo;NO\u0026rdquo;. If we don\u0026rsquo;t see any collision, simply print \u0026ldquo;YES\u0026rdquo; after the loop.  Code Note: I did something a little different but the logic is the same. Basically if a room is occupied by multiple people in all parts, then some other room must be occupied by 0 guests in all parts (if those rooms were occupied as well, then the number of guests would exceed the number of rooms in the hotel).\nTime complexity: $\\mathcal{O}(n \\log n)$ for my specific implementation. Just use a boolean array for $\\mathcal{O}(n)$ complexity.\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt;using namespace std; int t, n, a; set\u0026lt;int\u0026gt; s; int mod(int x) { if (x \u0026lt; 0) return (x%n) + n; else return x%n; } int main() { cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a; s.insert(mod(mod(i) + mod(a))); } cout \u0026lt;\u0026lt; (s.size() == n ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; endl; s.clear(); } return 0; } ","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-6/hilberts-hotel/","summary":"Abridged Problem Statement Given an array $a$ of $n$ integers, output \u0026ldquo;YES\u0026rdquo; if for any integer 2 integers $i$ and $j$ ($-\\infty \\leq i \u0026lt; j \\leq \\infty)$, $i+a_{i \\bmod n} = j+a_{j \\bmod n}$, otherwise output \u0026ldquo;NO\u0026rdquo;. Go here for the full statement.\nSolution Note: If you don\u0026rsquo;t know shit about modular arithmetic, go here and learn about it. Also, we will be staying strictly in the realm of integers.","title":"Hilbert's Hotel"},{"content":"Abridged Problem Statement Given an integer $n$, find the longest subsequence $[1,2,\\ldots,n-1]$ whose product is $1$ modulo $n$.\nSolution Unfortunately I was not able to solve this problem but that is precisely why I\u0026rsquo;m writing this down. It will be even more unfortunate if I forget this and end up not being able to solve a easy problem.\nNote: read $a \\mid b$ as $a$ divides $b$ and $a \\nmid b$ as $a$ does not divide $b$.\nSo, let\u0026rsquo;s call the product of our subsequence $p$. Of course, $p$ and $n$ should not have any common factor greater than 1. Let\u0026rsquo;s prove the previous statement. Let $f$ be an integer such that $f \\mid p$ and $f \\mid n$ so let $p = fa$ and $n = fb$. Then we have: $$ fa=qfb+r \\\\[0.7em] \\implies qf(a-b) = r $$ If $f \u0026gt; 1$, then we can see that the remainder is a multiple of $f$. This means that all of $p$\u0026rsquo;s factors should be all positive integers $i$ such that $\\gcd (i, n) = 1$. But notice that by multiplying all such $i$, we might not get a number which is $1$ modulo $n$. This can be observed in the 1st sample test as $1 \\times 2 \\times 3 \\times 4 \\equiv 4 \\pmod 5$. So how do we ensure that the remainder is still 1? Let\u0026rsquo;s call this remainder $r$. If $r=1$, we are done but if $r \\neq 1$, we need to fix that. Now, notice that $r \\nmid n$. Let\u0026rsquo;s prove this by contradiction: if $r \\mid n$, $r \\mid p$ is also true, but we already decided that $p$ should not have a factor which divides $n$, hence we have reached a contradiction. Also, since $\\gcd (r, n) = 1$, $r$ must be a factor of $p$ (that is how we constructed $p$ in the first place). Let $p = rq$. Then we have: $$ rq \\equiv r \\pmod n \\\\[0.7em] q \\equiv 1 \\pmod n $$ We just cancelled out the $r$ from both sides. If you don\u0026rsquo;t understand how that worked (which was what tripped me up) this video explains it nicely. So after getting our initial $p$, if we see that $p \\not\\equiv 1 \\pmod n$, we should simply remove $p \\bmod n$ from $p$\u0026rsquo;s factors, essentially doing $\\frac{p}{p \\bmod n}$.\nCode Time complexity: $\\mathcal{O}(n \\log n)$. But take that with a grain of salt because I literally just googled \u0026ldquo;time complexity of euclidian algorithm for gcd\u0026rdquo; and it looked like this is about correct. Here is the article where I found this.\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; typedef long long ll; ll n; set\u0026lt;ll\u0026gt; s; void solve() { ll prod = 1; for (ll i = 1; i \u0026lt; n; i++) { if (__gcd(i, n) == 1) { s.insert(i); prod *= i; prod %= n; } } if (prod != 1) s.erase(prod); } int main() { cin \u0026gt;\u0026gt; n; solve(); cout \u0026lt;\u0026lt; s.size() \u0026lt;\u0026lt; endl; for (ll i: s) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-6/product-1-modulo-n/","summary":"Abridged Problem Statement Given an integer $n$, find the longest subsequence $[1,2,\\ldots,n-1]$ whose product is $1$ modulo $n$.\nSolution Unfortunately I was not able to solve this problem but that is precisely why I\u0026rsquo;m writing this down. It will be even more unfortunate if I forget this and end up not being able to solve a easy problem.\nNote: read $a \\mid b$ as $a$ divides $b$ and $a \\nmid b$ as $a$ does not divide $b$.","title":"Product 1 Modulo N"},{"content":"Abridged Problem Statement Given an array of $a$ of length $n$, determine how many elements and which elements should be removed from $a$ so that the following condition does not hold:\n$a$ can be separated into 2 subsequences $b$ and $c$ containing distinct elements, such that $|b| + |c| = |a|$ and $\\sum_{i = 1}^{|b|} b_i = \\sum_{j = 1}^{|c|} c_j$. Here, $|x|$ denotes the length of the array $x$.\nSolution Let\u0026rsquo;s first tackle the case of 0 removals. Well we can just check for this using DP. I won\u0026rsquo;t discuss this case here because then this post will become too long. Refer to this or this to see a very similar problem\u0026rsquo;s solution. Now, the more interesting case is where we do need to remove elements. Assume I am talking about the case for more than 0 removals for the rest of this post. Let $S_a = \\sum_{i = 1}^{|a|} a_i$. It\u0026rsquo;s obvious that $S_a$ must be even. For $S_a$ to be even, $a$ must contain an even number of odd elements. Let\u0026rsquo;s again separate the problem into 2 cases:\n  $a$ contains greater than 0 odd elements\nWe can simply remove one odd element and we will be done. Since now $a$ will contain an odd number of odd elements, $S_a$ will be odd too.\n  $a$ contains 0 odd elements\nInstead of isolating this case, let\u0026rsquo;s try to arrive at this from case 1. Let\u0026rsquo;s say $a$ does contain more than 0 odd elements for now. Let the \u0026ldquo;bad\u0026rdquo; subsequences be $b$ and $c$ ($S_b + S_c = S_a$). Since we are still at case 1 (for now), we can still just remove any odd element. Now let\u0026rsquo;s multiply every element in $a$ by 2, hence finally arriving at the 2nd case. But notice that $b$ and $c$ will still contain the same elements (just multiplied by 2). And we can multiply by 2 however many times we want, but $b$ and $c$ will still contain the same elements. Which means we can remove the odd element and we are done.\n  So we\u0026rsquo;ve proven that either 0 or 1 element needs to be removed. In the first case, it\u0026rsquo;s obvious which element needs to be removed but in the second case, how do we decide that? Well we should find the element which is closest to being odd, meaning it has the least powers of 2 in its prime factorization. And that is pretty easy to do.\nCode Time complexity: $\\mathcal{O}\\left( n \\cdot \\sum_{i = 1}^{n} a_i \\right)$. Since it\u0026rsquo;s a table with empty cells, that stuff just becomes max value of $n$ which is $100$ times max value of the sum which is $2000 \\cdot 100$.\n#include \u0026lt;iostream\u0026gt;using namespace std; int n, total = 0, arr[105]; bool dp[105][200005]; void fillDP() { for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 1; for (int j = 0; j \u0026lt; 200005; j++) { if (not dp[i][j]) continue; dp[i + 1][j] = 1, dp[i + 1][j + arr[i]] = 1; } } } int lsb(int x) { int ans = 0; while (x%2 == 0) { ans += 1; x /= 2; } return ans; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; arr[i]; total += arr[i]; } fillDP(); if (total%2 or not dp[n][total/2]) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; int ans = 0; for (int i = 0; i \u0026lt; n; i++) { if (lsb(arr[i]) \u0026lt; lsb(arr[ans])) ans = i; } cout \u0026lt;\u0026lt; ans + 1 \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-6/baby-ehab-partitions-again/","summary":"Abridged Problem Statement Given an array of $a$ of length $n$, determine how many elements and which elements should be removed from $a$ so that the following condition does not hold:\n$a$ can be separated into 2 subsequences $b$ and $c$ containing distinct elements, such that $|b| + |c| = |a|$ and $\\sum_{i = 1}^{|b|} b_i = \\sum_{j = 1}^{|c|} c_j$. Here, $|x|$ denotes the length of the array $x$.","title":"Baby Ehab Partitions Again"},{"content":"Abridged Problem Statement There is no abridged problem statement. Go here for full statement.\nSolution Note: Points on the OX line will be 1-indexed, meaning 1st point from left will be at (1, 0). For the rest of this, the y-coordinate will be ignored.\nFirst, we will make a few observations. For that, we will very much require a picture.\nThis is the solution of the 3rd sample input, with $n=3$. Let\u0026rsquo;s label each of the arcs, or segments $R,G,B$ just because they\u0026rsquo;re like that in the picture as well. For any segment $S$, the starting point and ending point of that segment is denoted by $S_l$ and $S_r$ respectively.\nNow that terminologies are out of the way, let\u0026rsquo;s make a few observations.\n  First, notice the following: in solution 2, 3 and 4 of the above image, $R$ contains all the other segments. The effective range went from $[1,6]$ to $[2,4]$. Range $[2,4]$ has length 2, and from the sample output we know that the length 2 has 3 solutions. This means that we can solve for any range independently (these are the subproblems) and combine them efficiently with the bigger range (the larger problem that we are trying to solve). Hence we can use dynamic programming.\n  Now, we consider the rules that we need to follow. Let\u0026rsquo;s do it case by case. Suppose we have an effective range $[l,r]$.\n  Case 1: All segments in range are equal.\nLet\u0026rsquo;s place $A$ and $A_l = l$. Now, of course we need place same length segments starting at all points $i$ such that $A_l \u0026lt; i \u0026lt; A_r$. Let the rightest segment starting on one of these points be $B$, so we have $B_l = A_r - 1$. Hence the length of the whole thing (length of range $[A_l, B_r]$) is $A_r - 1 + \\text{len($B$)} - A_l$ which is equal to $2(A_r - A_l) - 1$. But instead we will use the number of points (which is $2(A_r - A_l)$) taken up by this placement instead of the length. To explain why we do this, look at the 1st solution, notice that there are 2 unit lengths which none of the segments occupy. There are ways to account for this, but instead we will just use the number of points. Hence, we have: $$ q \\cdot (\\text{number of points in range $[A_l, B_r]$}) = \\text{number of points in range $[l, r]$} \\\\[0.7em] \\implies 2q(A_r - A_l) = r - l + 1 \\\\[0.7em] \\implies A_r - A_l = \\frac{r - l + 1}{2q} $$\nSo this means we are looking for all $A_r - A_l$ which are factors of $\\frac{r-l+1}{2}$.Hence, for case 1, our number of ways is $D\\left(\\frac{r - l + 1}{2}\\right)$ where $D(x)$ is a function which gives the number of factors $x$ has. You can compute this using the $\\mathcal{O}(\\text{MAXN} \\log \\text{MAXN})$ counting divisors algorithm, which is the 3rd approach given in this video.\n  Case 2: All segments in range are not equal.\nAgain, let\u0026rsquo;s place $A$ and $A_l = l$. With a little bit of scribbling examples, its easy to see that we can leave $2, 4, \\ldots , A_r - A_l + 1 - 2$ points in the middle unused. Meaning, except for the middle points, all the other points at the sides will be occupied by segments which have the same length as $A$. As we saw from (1), we can solve for these ranges independently and store their results in a $dp$ array.\n    The only thing remaining is convincing ourselves that we have all cases covered. You can read this post over and over again to convince yourself of this, since proving this is quite wordy.\n  So our algorithm is the following, let $dp$ be our memoization array which will store the result, or solution for number of points equal to $i$. Therefore, $$ dp_i = \\begin{cases} 0 \u0026amp; \\text{if $i = 2m+1$} \\\\[0.5em] D(i)+\\sum_{j=2}^{2i-2} dp_j \u0026amp; \\text{otherwise} \\end{cases} $$ This still has $\\mathcal{O}(n^2)$ running time if we compute the $d_2, \\ldots, d_{i-2}$ sum every time. I was getting TLE because I wasn\u0026rsquo;t noticing this. So I made the $dp$ array a prefix-summed array so I just do $dp_{2i} = D(i) + dp_{2i - 2}$. Of course the answer is simply $dp_{2n}$.\nCode Time complexity: $\\mathcal{O}(n)$\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; typedef long long ll; ll MOD = 998244353; ll n, factors[2000005], memo[2000005]; void setup() { for (ll i = 1; i \u0026lt;= 2000005; i++) { for (ll j = i; j \u0026lt;= 2000005; j += i) { factors[j] += 1; } } } ll solve(ll l) { if (l == 0) return 0; if (memo[l] != 0) return memo[l]; memo[l] += factors[l/2]; memo[l] %= MOD; memo[l] += solve(l-2); memo[l] %= MOD; if (l \u0026lt; 2*n) { memo[l] += solve(l-2); memo[l] %= MOD; } return memo[l]; } int main() { setup(); cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; solve(2*n) \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-6/kavi-on-pairing-duty/","summary":"Abridged Problem Statement There is no abridged problem statement. Go here for full statement.\nSolution Note: Points on the OX line will be 1-indexed, meaning 1st point from left will be at (1, 0). For the rest of this, the y-coordinate will be ignored.\nFirst, we will make a few observations. For that, we will very much require a picture.\nThis is the solution of the 3rd sample input, with $n=3$.","title":"Kavi on Pairing Duty"},{"content":"The unrelated counting problem First, let\u0026rsquo;s talk about a seemingly unrelated counting puzzle. In an $n \\times m$ grid, let each cell be denoted as $(\\text{row number, column number})$. The top-left cell will be $(1,1)$ and bottom-right cell will be $(n,m)$. If the only allowed direction is right and down, count the number of ways to go from $(1,1)$ to $(n,m)$.\nSolution With Counting Let $f(x,y)$ be the number of ways to go to cell $(x,y)$. Notice that for any cell, you reach it from either the cell above it, or from the cell to the left of it. This diagram should illustrate it nicely:\nSo we get the following recurrence relation: $$ f(x,y) = \\begin{cases} f(x-1,y)+f(x,y-1) \u0026amp; \\text{if $x,y \u0026gt; 1$} \\\\[0.5em] 1 \u0026amp; \\text{otherwise} \\end{cases} $$\nSolution with combinatorics Let D and R be the action of going down and right respectively. In a sequence of DDD\u0026hellip;RRR\u0026hellip; which takes us to cell $(n,m)$, the number of D\u0026rsquo;s will be $n-1$ and the number of R\u0026rsquo;s will be $m-1$. So the above problem is simplified to the following problem: how many different arrangements does the sequence DDD\u0026hellip;RRR\u0026hellip; have? If you have ever studied combinatorics, the answer will be immediately obvious: $$ f(x,y) = {x+y-2 \\choose x-1} $$ If you don\u0026rsquo;t understand how this works, go here for the Wikipedia page and here to get a brief understanding.\nRelating to Pascal\u0026rsquo;s Triangle Here is a picture of Pascal\u0026rsquo;s triangle to help us understand:\nNote: I\u0026rsquo;ll use 1-based indexing meaning row numbers and column numbers will start from 1.\nLet\u0026rsquo;s try to calculate the 2nd number on the 5th row, which is 4. Some of the numbers have been marked out because we don\u0026rsquo;t need those when trying to calculate the 4 we want, we are only concerned with the numbers that we need. This also follows what we want from the Binomial theorem, we don\u0026rsquo;t always want to find all the coefficients, we always calculate a single coefficient.\nNow, notice that after removing the unnecessary cells, the remaining cells will form a rectangle (from the 1st cell to our desired cell). You might already see where I\u0026rsquo;m going with this. But proving that is out of the scope for this article (also, I can\u0026rsquo;t prove it). Let the desired number be on row $x$ and column $y$ of the triangle. Then our rectangle will have $x-y+1$ rows and $y$ columns.\nBut notice how we count each cell in pascal\u0026rsquo;s triangle. It\u0026rsquo;s not that difficult to see that this pattern of counting is identical to our SUCP (Seemingly Unrelated Counting Problem). I recommend deriving the binomial theorem from here on yourself. But you can read further if you want.\nDeriving the Binomial Theorem Let $g(x,y)$ be the number on row $x$ and column $y$ of the triangle. So the recurrence relation is: $$ g(x,y) = \\begin{cases} g(x-1,y-1)+g(x-1,y) \u0026amp; \\text{if $x,y \u0026gt; 1$} \\\\[0.5em] 1 \u0026amp; \\text{otherwise} \\end{cases} $$ This is also a formula for the binomial theorem but nobody uses this. Naturally, we are more concerned about the closed-form formula. We already know that $x$ is the exponent we are raising our binomial to and we are calculating the $y^\\text{th}$ of the expansion. Since we already have the dimensions of the rectangle, we can simply input them in here and get this: $$ g(x,y) = {x-y+1-1+y-1 \\choose y-1} = {x-1 \\choose y-1} $$\nSome interesting relations to CS A naive implementation of the recursive algorithm is this:\nfunction countPathsInGrid(x, y): if x is 1 or y is 1: return 1 else: return countPathsInGrid(x-1, y) + countPathsInGrid(x, y-1) This results in exponential time complexity. This implementation uses $\\mathcal{O}(1)$ memory. This algorithm\u0026rsquo;s speed can be improved using dynamic programming:\nlet ways[i][j] store the number of ways to go from (1,1) to (i,j) function countPathsInGrid(x, y): if ways[i][j] is known: return ways[i][j] else if x is 1 or y is 1: return 1 else: ways[i][j] = countPathsInGrid(x-1, y) + countPathsInGrid(x, y-1) return ways[i][j] Now, the time complexity has been reduced to only $\\mathcal{O}(nm)$ but the memory complexity has increased to $\\mathcal{O}(nm)$. The memory complexity can be reduced further by counting ways row by row, so the ways array will only store values from the above row. But the speed of this algorithm can be further improved without sacrificing memory:\nfunction countPathsInGrid(x, y): ans = 1 for i such that x \u0026lt;= i \u0026lt;= x + y - 2: ans = ans * i for i such that 1 \u0026lt;= i \u0026lt;= x: ans = ans / i return ans The above algorithm has time complexity $\\mathcal{O}(\\max (n,m))$.\nSo, that is all I think I want to write in this post. I don\u0026rsquo;t like changing editing post after it\u0026rsquo;s published.\n","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-5/combinatorial-intuition-for-binomial-theorem/","summary":"The unrelated counting problem First, let\u0026rsquo;s talk about a seemingly unrelated counting puzzle. In an $n \\times m$ grid, let each cell be denoted as $(\\text{row number, column number})$. The top-left cell will be $(1,1)$ and bottom-right cell will be $(n,m)$. If the only allowed direction is right and down, count the number of ways to go from $(1,1)$ to $(n,m)$.\nSolution With Counting Let $f(x,y)$ be the number of ways to go to cell $(x,y)$.","title":"Combinatorial Intuition for the Binomial Theorem"},{"content":"Welcome to False Productivity! Hello hello hello. I am super excited about this for some reason. I wanted to do a blog for quite some time but it was a little daunting to see that even a simple blogging website was difficult to make (if you want to make it properly, not talking about a blog website with vanilla JS) so I kept putting it off for a long time. I did have another website like this but that one didn\u0026rsquo;t use markdown because I thought markdown couldn\u0026rsquo;t render math. I never saw any math equations on GitHub and as far as I remember, I think I looked a teensy bit into and gave up immediately. Then finally I found some inspiration\u0026hellip;\nEnter tmwilliamlin168 I found this Youtube channel called William Lin and watched a few videos of his. Then I borderline stalked him, and found his blog. After seeing that, I felt like some sort of duty was enthrusted upon me, that I needed to make a blog, otherwise I would be very sad. I don\u0026rsquo;t know why I felt like that but that really boosted my work rate for this project. I saw on his blog that he used NextJS and Tailwind CSS. So I decided that I would do the same. I went to learn NextJS. It said that I should first be familiar with ReatJS. So I went to learn ReactJS. Completed its tutorial in 6 hours and came back to learn NextJS\nThe Great Big Going While making their tutorial blog, I realized I HADN\u0026rsquo;T LEARNT SHIT. Literally everything in that tutorial went over my head. That\u0026rsquo;s why I soon gave up on Next. Lol no I didn\u0026rsquo;t. I was way in over my head so I decided it was time to install Tailwind. I had no clue what I was doing. But soon I ended up hating Tailwind because it required me to actually know CSS which was not gonna happen. So I got rid of it and tried out Bulma. This time I got a little further and managed to make a header for the landing page. It looked quite nice if I do say so myself. Then I proceeded to dump that entire project for something which was perfect for the job.\nStatic site generators FTW Yes, I discovered Jekyll. Then I discovered Hugo. Then I discovered PaperMod. Then I made this in 1 day. Life\u0026rsquo;s good.\n","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-5/first-post/","summary":"Welcome to False Productivity! Hello hello hello. I am super excited about this for some reason. I wanted to do a blog for quite some time but it was a little daunting to see that even a simple blogging website was difficult to make (if you want to make it properly, not talking about a blog website with vanilla JS) so I kept putting it off for a long time. I did have another website like this but that one didn\u0026rsquo;t use markdown because I thought markdown couldn\u0026rsquo;t render math.","title":"First Post!"}]