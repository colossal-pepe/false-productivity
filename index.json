[{"content":"The unrelated counting problem First, let\u0026rsquo;s talk about a seemingly unrelated counting puzzle. In an $n \\times m$ grid, let each cell be denoted as $(\\text{row number, column number})$. The top-left cell will be $(1,1)$ and bottom-right cell will be $(n,m)$. If the only allowed direction is right and down, count the number of ways to go from $(1,1)$ to $(n,m)$.\nSolution With Counting Let $f(x,y)$ be the number of ways to go to cell $(x,y)$. Notice that for any cell, you reach it from either the cell above it, or from the cell to the left of it. This diagram should illustrate it nicely:\nSo we get the following recurrence relation: $$ f(x,y) = \\begin{cases} f(x-1,y)+f(x,y-1) \u0026amp; \\text{if $x,y \u0026gt; 1$} \\\\[0.5em] 1 \u0026amp; \\text{otherwise} \\end{cases} $$\nSolution with combinatorics Let D and R be the action of going down and right respectively. In a sequence of DDD\u0026hellip;RRR\u0026hellip; which takes us to cell $(n,m)$, the number of D\u0026rsquo;s will be $n-1$ and the number of R\u0026rsquo;s will be $m-1$. So the above problem is simplified to the following problem: how many different arrangements does the sequence DDD\u0026hellip;RRR\u0026hellip; have? If you have ever studied combinatorics, the answer will be immediately obvious: $$ f(x,y) = {x+y-2 \\choose x-1} $$ If you don\u0026rsquo;t understand how this works, go here for the Wikipedia page and here to get a brief understanding.\nRelating to Pascal\u0026rsquo;s Triangle Here is a picture of Pascal\u0026rsquo;s triangle to help us understand:\nNote: I\u0026rsquo;ll use 1-based indexing meaning row numbers and column numbers will start from 1.\nLet\u0026rsquo;s try to calculate the 2nd number on the 5th row, which is 4. Some of the numbers have been marked out because we don\u0026rsquo;t need those when trying to calculate the 4 we want, we are only concerned with the numbers that we need. This also follows what we want from the Binomial theorem, we don\u0026rsquo;t always want to find all the coefficients, we always calculate a single coefficient.\nNow, notice that after removing the unnecessary cells, the remaining cells will form a rectangle (from the 1st cell to our desired cell). You might already see where I\u0026rsquo;m going with this. But proving that is out of the scope for this article (also, I can\u0026rsquo;t prove it). Let the desired number be on row $x$ and column $y$ of the triangle. Then our rectangle will have $x-y+1$ rows and $y$ columns.\nBut notice how we count each cell in pascal\u0026rsquo;s triangle. It\u0026rsquo;s not that difficult to see that this pattern of counting is identical to our SUCP (Seemingly Unrelated Counting Problem). I recommend deriving the binomial theorem from here on yourself. But you can read further if you want.\nDeriving the Binomial Theorem Let $g(x,y)$ be the number on row $x$ and column $y$ of the triangle. So the recurrence relation is: $$ g(x,y) = \\begin{cases} g(x-1,y-1)+g(x-1,y) \u0026amp; \\text{if $x,y \u0026gt; 1$} \\\\[0.5em] 1 \u0026amp; \\text{otherwise} \\end{cases} $$ This is also a formula for the binomial theorem but nobody uses this. Naturally, we are more concerned about the closed-form formula. We already know that $x$ is the exponent we are raising our binomial to and we are calculating the $y^\\text{th}$ of the expansion. Since we already have the dimensions of the rectangle, we can simply input them in here and get this: $$ g(x,y) = {x-y+1-1+y-1 \\choose y-1} = {x-1 \\choose y-1} $$\nSome interesting relations to CS A naive implementation of the recursive algorithm is this:\nfunction countPathsInGrid(x, y): if x is 1 or y is 1: return 1 else: return countPathsInGrid(x-1, y) + countPathsInGrid(x, y-1) This results in exponential time complexity. This implementation uses $O(1)$ memory. This algorithm\u0026rsquo;s speed can be improved using dynamic programming:\nlet ways[i][j] store the number of ways to go from (1,1) to (i,j) function countPathsInGrid(x, y): if ways[i][j] is known: return ways[i][j] else if x is 1 or y is 1: return 1 else: ways[i][j] = countPathsInGrid(x-1, y) + countPathsInGrid(x, y-1) return ways[i][j] Now, the time complexity has been reduced to only $O(nm)$ but the memory complexity has increased to $O(nm)$. The memory complexity can be reduced further by counting ways row by row, so the ways array will only store values from the above row. But the speed of this algorithm can be further improved without sacrificing memory:\nfunction countPathsInGrid(x, y): ans = 1 for i such that x \u0026lt;= i \u0026lt;= x + y - 2: ans = ans * i for i such that 1 \u0026lt;= i \u0026lt;= x: ans = ans / i return ans The above algorithm has time complexity $O(\\max (n,m))$.\nSo, that is all I think I want to write in this post. I don\u0026rsquo;t like changing editing post after it\u0026rsquo;s published.\n","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-5/combinatorial-intuition-for-binomial-theorem/","summary":"The unrelated counting problem First, let\u0026rsquo;s talk about a seemingly unrelated counting puzzle. In an $n \\times m$ grid, let each cell be denoted as $(\\text{row number, column number})$. The top-left cell will be $(1,1)$ and bottom-right cell will be $(n,m)$. If the only allowed direction is right and down, count the number of ways to go from $(1,1)$ to $(n,m)$.\nSolution With Counting Let $f(x,y)$ be the number of ways to go to cell $(x,y)$.","title":"Combinatorial Intuition for the Binomial Theorem"},{"content":"What will be explained The 2 claims below will be explained:\n If $a \\neq 0$, in any equation $ax^2+bx+c=0$, let the roots of this equation be $\\alpha$ and $\\beta$.\nClaim 1: $\\alpha + \\beta = {-b \\over a}$\nClaim 2: $\\alpha \\beta = {c \\over a}$\n Explanation Let $\\alpha = {-p \\over o}$ and $\\beta = {-r \\over q}$. Hence, we have: $$ (ox+p)(qx+r) = 0 \\\\[0.7em] \\implies ox(qx+r) + p(qx+r) = 0 \\\\[0.7em] \\implies oqx^2+orx+pqx+pr = 0 \\\\[0.7em] \\implies oqx^2+(or+pq)x+pr = 0 \\\\[0.7em] $$ In here $a=oq,b=or+pq,c=pr$.\nClaim 1: $$ \\alpha + \\beta = {-p \\over o} + {-r \\over q} \\\\[0.7em] = {-pq-ro \\over oq} \\\\[0.7em] = {-(or+pq) \\over oq} = {-b \\over a} $$ Claim 2: $$ \\alpha \\beta = {-p \\over o} \\cdot {-r \\over q} \\\\[0.7em] = {pr \\over oq} = {c \\over a} $$ Thank you for coming to my TEDTalk.\n","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-5/quadratic-equation-roots/","summary":"What will be explained The 2 claims below will be explained:\n If $a \\neq 0$, in any equation $ax^2+bx+c=0$, let the roots of this equation be $\\alpha$ and $\\beta$.\nClaim 1: $\\alpha + \\beta = {-b \\over a}$\nClaim 2: $\\alpha \\beta = {c \\over a}$\n Explanation Let $\\alpha = {-p \\over o}$ and $\\beta = {-r \\over q}$. Hence, we have: $$ (ox+p)(qx+r) = 0 \\\\[0.7em] \\implies ox(qx+r) + p(qx+r) = 0 \\\\[0.","title":"Sum and Product of Roots in Quadratic Equations"},{"content":"Abridged Problem Statement Given an array $a$ containing $n$ points on the coordinate plane, find the minimum angle required to cover all $n$ points in your view if you\u0026rsquo;re standing in the origin.\nSolution Let\u0026rsquo;s take the second sample input in the actual problem statement as an example.\nThere are 3 points: $A = (2,0)$, $B = (0, 2)$, $C = (-2, -2)$. And the graph would look like this:\nFor each problem, we want to have our angle so that 2 or more points are on the border of our angle. For example, in here, those points would be point A and C. So how do we find the minimum such angle? Let\u0026rsquo;s find the angle which covers all the points for every pair of points (worry about the implementation later). For each par, the required angle is below.\n   Pair Angle     Pair (A, B) 270 - clockwise   Pair (B, C) 315 - clockwise   Pair (C, A) 135 - counter clockwise    Let\u0026rsquo;s say there\u0026rsquo;s another point $D=(2, 2)$. If that was the case, neither the clockwise angle nor the counter-clockwise angle for pair (A, B) would be valid since the clockwise angle would not cover point D and the counter-clockwise angle would not cover point C. Hence we have proved that we need to take the clockwise or counter-clockwise angle between every pair of adjacent points. Adjacent points are the closest 2 or less closest points to a point, one in the clockwise direction, another in the opposite direction. But how do we know which point is adjacent to some other point? We sort the points counter-clockwise. The function counterClockWiseAngle(Point P) returns the counter-clockwise of point P from positive side of x-axis. For example, for points A, B, and C, their counter-clockwise angles are 0, 90, 135 respectively. Now, find the minimum outside angle between every pair of points $a_i$ and $a _{i+1}$ where $1 \\leq i \\leq n-1$. Outside angle is basically the clockwise-angle from point A to point B. Look at the code to get the formula. But there is a catch. Notice that we haven\u0026rsquo;t calculated the outside angle between $a_n$ and $a_0$. This is because their outside angle does not contain any of the other points. You can see this to be true in the above example; for the pair $(a_n, a_0)$, compute their inside angle (counter-clockwise angle from point A to B) which does contain the other points. So we have processed all pairs one by one and should have a minimum by now.\nCode Note: This gets runtime error with the G++17 compiler, so I used MS C++ 2017 to get AC.\nTime complexity: $O(n \\log n)$\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;iomanip\u0026gt;using namespace std; struct Point { int x, y; Point(int a, int b) { x = a, y = b; } }; int n, xi, yi; double PI = 3.14159265358, ans = 360; vector\u0026lt;Point\u0026gt; plane; double deg(double d) { return d*(180/PI); } double counterClockWiseAngle(Point p) { double angle = deg(atan2(p.y, p.x)); if (angle \u0026gt;= 0) return angle; else return 360 + angle; } double insideAngle(Point p1, Point p2) { return fabs(counterClockWiseAngle(p1) - counterClockWiseAngle(p2)); } double outsideAngle(Point p1, Point p2) { return 360 - insideAngle(p1, p2); } bool comparePoint(Point p1, Point p2) { return counterClockWiseAngle(p1) \u0026lt; counterClockWiseAngle(p2); } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; xi \u0026gt;\u0026gt; yi; plane.push_back({xi, yi}); } sort(plane.begin(), plane.end(), comparePoint); if (plane.size() == 1) ans = 0; else { for (int i = 0; i \u0026lt; n-1; i++) { ans = min(ans, outsideAngle(plane[i], plane[i+1])); } ans = min(ans, insideAngle(plane[n-1], plane[0])); } cout \u0026lt;\u0026lt; setprecision(11) \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-5/view-angle/","summary":"Abridged Problem Statement Given an array $a$ containing $n$ points on the coordinate plane, find the minimum angle required to cover all $n$ points in your view if you\u0026rsquo;re standing in the origin.\nSolution Let\u0026rsquo;s take the second sample input in the actual problem statement as an example.\nThere are 3 points: $A = (2,0)$, $B = (0, 2)$, $C = (-2, -2)$. And the graph would look like this:","title":"View Angle"},{"content":"Abridged Problem Statement Given 3 integers $a,b,c$, find all values of $x$ between 0 and 10^9 for which the equation $x=b\\cdot s(x)^a+c$ holds where $s(x)$ is the digit sum of $x$.\nSolution Since maximum value of $x$ is 10^9, a $\\mathcal{O}(x)$ solution is infeasible. So we need make the search space smaller. Let\u0026rsquo;s express the original equation in 2 ways:\n$$ x=b\\cdot s(x)^a + c \\tag{1} $$ $$ \\sqrt[a]{x-c \\over b} = s(x) \\tag{2} $$\nNotice that in equation 2, the left side might not be an integer and if $a \u0026gt; 1$, it might be irrational. We know that the set of positive integers is smaller than the set of rational and real numbers. So, if we can search in such a way that we omit all the non-integer values of $s(x)$ while searching for $x$, we will have reduced our search space by a lot. Now, let\u0026rsquo;s think about what $s(x)$ could be since we are only restricted to integers. Well its obvious that $s(x) \\geq 0$ and since maximum value of $x$ is 10^9, we can fill all digits with 9\u0026rsquo;s so that we have a 9 digit number with all 9\u0026rsquo;s. This means $0 \\leq s(x) \\leq 81$. Which means instead of searching through all values of $x$, we want to search through all possible values of $s(x)$. So for every $i$ between 0 and 81, we compute $x=b\\cdot i^a+c$ and check if $s(x)=i$ and if it is, we add it to our list of solutions.\nCode Time complexity: $O(1)$\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; long long intPow(int b, int p) { long long ans = 1; for (int i = 0; i \u0026lt; p; i++) { ans *= b; } return ans; } int s(int x) { int dig_sum = 0; while (x) { dig_sum += x%10; x /= 10; } return dig_sum; } long long bound(int a) { if (a == 1) return 820000; else return 999999999; } bool validSolution(int i, int a, int b, int c) { return ((long long)i == s(intPow(i, a)*b + c)); } int main() { int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; vector\u0026lt;int\u0026gt; v; for (int i = 1; b*intPow(i, a) + c \u0026lt;= bound(a); i++) { if (validSolution(i, a, b, c)) v.push_back(intPow(i,a)*b + c); } cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; for (int i: v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-5/little-dima-and-equation/","summary":"Abridged Problem Statement Given 3 integers $a,b,c$, find all values of $x$ between 0 and 10^9 for which the equation $x=b\\cdot s(x)^a+c$ holds where $s(x)$ is the digit sum of $x$.\nSolution Since maximum value of $x$ is 10^9, a $\\mathcal{O}(x)$ solution is infeasible. So we need make the search space smaller. Let\u0026rsquo;s express the original equation in 2 ways:\n$$ x=b\\cdot s(x)^a + c \\tag{1} $$ $$ \\sqrt[a]{x-c \\over b} = s(x) \\tag{2} $$","title":"Little Dima and Equation"},{"content":"Welcome to False Productivity! Hello hello hello. I am super excited about this for some reason. I wanted to do a blog for quite some time but it was a little daunting to see that even a simple blogging website was difficult to make (if you want to make it properly, not talking about a blog website with vanilla JS) so I kept putting it off for a long time. I did have another website like this but that one didn\u0026rsquo;t use markdown because I thought markdown couldn\u0026rsquo;t render math. I never saw any math equations on GitHub and as far as I remember, I think I looked a teensy bit into and gave up immediately. Then finally I found some inspiration\u0026hellip;\nEnter tmwilliamlin168 I found this Youtube channel called William Lin and watched a few videos of his. Then I borderline stalked him, and found his blog. After seeing that, I felt like some sort of duty was enthrusted upon me, that I needed to make a blog, otherwise I would be very sad. I don\u0026rsquo;t know why I felt like that but that really boosted my work rate for this project. I saw on his blog that he used NextJS and Tailwind CSS. So I decided that I would do the same. I went to learn NextJS. It said that I should first be familiar with ReatJS. So I went to learn ReactJS. Completed its tutorial in 6 hours and came back to learn NextJS\nThe Great Big Going While making their tutorial blog, I realized I HADN\u0026rsquo;T LEARNT SHIT. Literally everything in that tutorial went over my head. That\u0026rsquo;s why I soon gave up on Next. Lol no I didn\u0026rsquo;t. I was way in over my head so I decided it was time to install Tailwind. I had no clue what I was doing. But soon I ended up hating Tailwind because it required me to actually know CSS which was not gonna happen. So I got rid of it and tried out Bulma. This time I got a little further and managed to make a header for the landing page. It looked quite nice if I do say so myself. Then I proceeded to dump that entire project for something which was perfect for the job.\nStatic site generators FTW Yes, I discovered Jekyll. Then I discovered Hugo. Then I discovered PaperMod. Then I made this in 1 day. Life\u0026rsquo;s good.\n","permalink":"https://colossal-pepe.github.io/false-productivity/posts/2021-5/first-post/","summary":"Welcome to False Productivity! Hello hello hello. I am super excited about this for some reason. I wanted to do a blog for quite some time but it was a little daunting to see that even a simple blogging website was difficult to make (if you want to make it properly, not talking about a blog website with vanilla JS) so I kept putting it off for a long time. I did have another website like this but that one didn\u0026rsquo;t use markdown because I thought markdown couldn\u0026rsquo;t render math.","title":"First Post!"}]